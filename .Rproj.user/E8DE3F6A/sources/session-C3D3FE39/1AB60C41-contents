 #option - <-
  
  # Writing your own functions ####

add <- function(x, y) { #this function takes as input two nunbers, x and y
  return(x + y) # and returns their sum
}

add(x = 3, y =2)

(z <- add(x = 3, y = 2))

z

print_words <- function(x, y) {
  print(paste(x, y))
}

print_words(x = "hello", y = "Simona!")

# Data types ####

# integer, numeric, characters, logical

# Character data
x <- "1"

class(x)

# anything you give in quotes is CHARACTER

# Integers and Numeric

x <- 1

class(x)

x <- as.integer(1)

# must tell R its integer or it will be numeric

class(x)

# Logical

x <- TRUE

class(x)

# Object types ####

## Vectors ####

x <- c(1, 2, 3, 4, 5)
class(x)
x
length(x) #how many points in vector

y <- 1 # this is also a vector
length(y)

z <- c("A", "B", "C")
class(z)
length(z)

new_vector <- c(1, "A", "B", 10)
class(new_vector)
as.numeric(new_vector)
new_vector

new_vector <- c(5, TRUE, FALSE)
class(new_vector)
new_vector

logical_vector <- c(TRUE, FALSE, TRUE, TRUE)
sum(logical_vector) #how many true elements

# Factors ####

years <- factor(c(2021, 2022, 2023, 2022))

years

#levels are associated with each year
#each level gets an index value

as.numeric(years)
as.numeric(levels(years))

# Data frames ####

df <- data.frame(
  numbers = c(1, 2, 3),
  letters = c("A", "B", "C"),
  colors = factor(c("blue", "red", "green"))
)

# each column must have same number of elements

str(df)
df

# Subsetting ####

df$numbers
df$numbers[3] #gives 3rd element of vector
df$letters[3]

df[3, 2] #row and column position
df[3, ] #everything in 3rd row

class(df[, 2])

# Subsetting 2 columns at a time

df[, c(1, 2)]

# How to remove columns/rows
df[-1, ]
df[, -1]
df[-c(1,2), ]

# Matrices ####

mat <- matrix(nrow = 5, ncol = 5, data = 1:25)
mat
t(mat)

mat[3,2]

arr <- array(data = 1:24, dim = c(2, 4, 3))

arr[1, 4, 2]

# Conditional subsetting ####

# Logical conditions < > == !=

10 > 5
10 < 5
10 == 5 # one = is same as <-
10 != 5

#These are the same
x <- 1
x = 1

# Subset a data frame based on a logical condition
df[df$colors == "green", ] #return all rows with color green

df[df$numbers == 2, ]
df[df$colors == "green" & df$numbers == 2, ] #nothing fits
df[df$colors == "green" | df$numbers == 2, ] #change and with or

## Lists ####

list1 <- list(1, 1:3, 1:10) #set of different numeric vectors, in a df all must be same length

list2 <- list(1:10, c("dog", "cat", "mouse"), c(TRUE, FALSE))

list3 <- list(1:10, df)

list3[[1]] #subset the first element in the list, double bracket if you want the object
list3[1] #this is different

names(list3) <- c("vector", "data.frame") #name elements in the list

list3$vector #then can subset based on the names

#use class() to check content return - list or integer

list3[[2]]
list3[[2]]$letters 
list3[[2]][1, ]
identical(list3[[2]], df) #identical - are these things the same

# Control structures ####

# switches pieces of code on and off

# if(condition) {  do something
#  } 

vec <- 1:10
  
if(vec == 3) {
  print(vec +1)
}

animal <- "dog"

if (animal == "cat") {
  print("I have a cat")
}

if (animal == "cat") {
  print("I have a cat")
} else {
  print("I have a dog")
}

# Repeating operations ####

## Vectorization ####

vec <- 1:10

# I want to add 1 to each element of this vector

vec + 1 # this is a vectorized operation

vec > 5 # this is another vectorized operation

new_vec <- 2:11

vec + new_vec # this is another vectorized operation

new_vec <- 1:3

length(vec)
length(new_vec)

vec + new_vec # warning because different lengths, recycles second vector elements
# NEVER IGNORE THIS WARNING MESSAGE
# if you do use a multiple, still the same thing but NO WARNING!!!!!
# this is faster than for-loops, so if it works, do it instead

# You need a forloop when next value depends on the previous one

# Loops ####

## For Loops ###

for (i in 1:10) {
  print(1)
}

# for (NUMBER OF TIMES YOU WANT LOOP REPEATED){WHAT YOU WANT IT TO DO}

for (i in 1:10) {
  x <- i * 2
  y <- x^2
  print(y)
}

res <- c() # empty vector container to then fill, MUST DO FIRST
# could do an empty DF... etc.

for (i in 1:10) {
  x <- i * 2
  y <- x^2
  res[i] <- y      #store the results
}

for (element in 1:10) {
  x <- element * 2
  y <- x^2
  res[element] <- y      #can use whatever instead of i for the symbol
}

for (i in 1:10) {
  print("hello!")
}

for (i in 1:10) {
  print(paste("hello! ", i))
}

## While Loops ###

i <- 1

while (i < 6) {
  print(i)
  i <- i + 1
}

i <- 1

while(i < 6){
  i <- i +1
  print(i)
}

## Repeat Loop ####

#repeates the loop until we tell it to stop

i <- 1

repeat{
  print(i)
  i <- i + 1
  if (i > 5) {
    break # the break is when to stop
  }
}

vec <- c(1, 10, 2, 9, 3, 8, 4, 7, 5, 6)

for (i in vec) {
  if (i < 5) {
    print(i)
  } else {
    next
  }
}

for (i in vec) {
  if (i < 5) 
    print(i)
}

for (i in vec) {
  if (i < 5) {
    print(i)
  } else {
    vec <- vec[-i] #this didn't really do what we wanted
    #using positional index, so removing the 10th element
  }
}

# The apply family ####

# Functions in this family include apply, lapply, tapply, mapply, sapply...
# does not work on vector or lists

# lapply returns a list

# can cover most things with apply and lapply

mat <- matrix(data = 1:25, ncol = 5, nrow = 5)

# Row-wise sum

apply( X = mat, MARGIN = 1, FUN = sum)

# Column-wise sum
apply(X = mat, MARGIN = 2, FUN = sum)

# Column-wise custom operation
apply(X  mat, MARGIN = 2, FUN = function(x) {
  ((x * 2) + 5)^3
}
  )

#Turn mat into data frame

df <- as.data.frame(mat)
df$V3 <- c("A", "B", "C", "D", "E")

apply(df, 1, sum) # can't do it bc... 

apply(df, 1, function(x)
  {print(paste("Printing" , x))})

apply(df[,c(1:2, 4:5)], 1, sum)


# Example of lapply

l1 <- list(1:10, 2:20, 3:30)

lapply( X = l1, FUN = sum)
lapply(X = l1, FUN = function(x) {(x + 10) * 456})

# Examples of repeated operations in real life

# Example 1 ####

# Check which data (diet, GPS, morphometrics) is available for each
# dragon individual in the dataset

# Load DBI
library(DBI)

# Connect to the database
dragons_db <- dbConnect(drv = RSQLite::SQLite(),
                "/Users/tthorpe7/Documents/WILD6900/dragons_practice/dragons_practice.db")

# Load relevent tables

# This won't work bc we made too many db files and I picked the wrong one 

diet <- dbGetQuery(conn = dragons_db,
                   "SELECT * FROM diet;")
gps <- dbGetQuery(conn = dragons_db,
                  "SELECT * FROM gps_data";)
morphometrics <- dbGetQuery(conn = dragons_db,
                            "SELECT * FROM morphometrics;")
dragons <- dbGetQuery(conn = dragons_db,
                      "SELECT * FROM dragons";)                        

head(dragons)

inds <- dragons$dragon_id
length(inds)

inds[1] %in% morphometrics$dragon_id

inds[1] %in% gps$dragon_id

system.time({inds[1] %in% unique(gps$dragon_id) }) 
# how to see how long it takes for something to run
# useful to make code more efficient
# can calculate how long it takes for loops to run

inds[1] %in% unique(gps$dragon_id) 

# Create empty dataframe
res <- data.frame(dragon_id = NA,
                  has_morphometrics = NA,
                  has_gps = NA,
                  has_diet = NA)

gps_ids <- unique(dragons$dragon_id) #faster to do this first

for (i in 1:length(inds)) {

res[i, ]$dragon_id <- inds[i]  
    
res[i, ]$has_morphometrics <- inds[i] %in% morphometrics$dragon_id
res[i, ]$has_diet <- inds[i] %in% diet$dragon_id
res[i, ]$has_gps <- inds[i] %in% gps_ids

}

# Find individuals that have GPS and diet data

res$has_gps == TRUE & res$has_diet == TRUE
res[res$has_gps & res$has_diet, ] # same as above

# How many rows?
nrow(res[res$has_gps & res$has_diet, ])

length(res[res$has_gps & res$has_diet, ]$dragon_id) #gets length of vector

# Example 2 ####

#import csvs and combine into one dataframe
files <- list.files(path = "", pattern = ".csv", full.names = TRUE)

results <- data.frame ()

for (i in 1:length(files)) {
  csv <- read.csv(files[i])
  results <- rbind(results, csv)
}

for (i in files) {
  csv <- read.csv(i)
  results <- rbind(results, csv)
} #does same thing as above, but takes longer

# Do the same thing with lapply

csv_list <- lapply(files, FUN = read.csv)
#lapply almost always faster than a loop

res3 <- do.call("rbind", csv_list)

nrow(res3)

# Example 3 ####

# Make a set of plots representing regression lines with
#different intercepts or slopes

# Values of x-axis

x <- 1:10

# Slope coeffcient

m <- 0.5

#Calculate vales on y axis

y <- m * x

# Plot

plot(x=x, y=y, type = "1")

# Say we have a set of slopes

slopes <- seq(from = 0, to = 1, by = 0.01)

# Plot in the loop

for (m in slopes) {
  y <- m * x
  pdf(file = paste0("plots/plot_slope_", m, ".pdf",
                    height = 4, width = 4))
  plot(x=x, y=y, type = "1", ylim = c(0,10),
       main = paste("Slope = ", m))
  dev.off()
  
}
#creating pdf file plot for each slope

# Same thing with lapply

plot_list <- lapply (X = slopes, FUN = function(m) {
  y <- m * x
  pdf(file = paste0("plots/plot_slope_", m, ".pdf",
                    height = 4, width = 4, units = "in", res = 200))
  plot(x=x, y=y, type = "1", ylim = c(0,10),
       main = paste("Slope = ", m))
  dev.off()
  
})

plot(plot_list[[1]]) # plot 1 at a time, change number in brackets

# figure marins too large usually happens when figure won't fit in
# R studio window... DUMB